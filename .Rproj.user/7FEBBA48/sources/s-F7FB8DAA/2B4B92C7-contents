handle_error <- function(e) {
  print(e)
  # handled <<- TRUE
  # # First thing: Collect test error
  # test_error <<- e
  # 
  # # Increase option(expressions) to handle errors here if possible, even in
  # # case of a stack overflow.  This is important for the DebugReporter.
  # # Call options() manually, avoid withr overhead.
  # options(expressions = expressions_opt_new)
  # on.exit(options(expressions = expressions_opt), add = TRUE)
  # 
  # # Capture call stack, removing last calls from end (added by
  # # withCallingHandlers), and first calls from start (added by
  # # tryCatch etc).
  # e$expectation_calls <- frame_calls(11, 2)
  # 
  # test_error <<- e
  # 
  # # Error will be handled by handle_fatal() if this fails; need to do it here
  # # to be able to debug with the DebugReporter
  # register_expectation(e)
  # 
  # e$handled <- TRUE
  # test_error <<- e
}
handle_fatal <- function(e) {
  print(e)
  # handled <<- TRUE
  # # Error caught in handle_error() has precedence
  # if (!is.null(test_error)) {
  #   e <- test_error
  #   if (isTRUE(e$handled)) {
  #     return()
  #   }
  # }
  # 
  # if (is.null(e$expectation_calls)) {
  #   e$expectation_calls <- frame_calls(0, 0)
  }
  
  # register_expectation(e)
}
handle_expectation <- function(e) {
  print(e)
  # handled <<- TRUE
  # e$expectation_calls <- frame_calls(11, 6)
  # register_expectation(e)
  # invokeRestart("continue_test")
  test_expect<-test_expect+1
  
}
handle_warning <- function(e) {
  # When options(warn) >= 2, a warning will be converted to an error.
  # So, do not handle it here so that it will be handled by handle_error.
  if (getOption("warn") >= 2) return()
  
  handled <<- TRUE
  e$expectation_calls <- frame_calls(11, 5)
  register_expectation(e)
  invokeRestart("muffleWarning")
}
handle_message <- function(e) {
  print(e)
  # handled <<- TRUE
  # invokeRestart("muffleMessage")
}
handle_skip <- function(e) {
  print(e)
  # handled <<- TRUE
  # 
  # if (inherits(e, "skip_empty")) {
  #   # Need to generate call as if from test_that
  #   e$expectation_calls <- frame_calls(0, 12, frame - 1)
  # } else {
  #   e$expectation_calls <- frame_calls(11, 2)
  # }
  # 
  # register_expectation(e)
  # signalCondition(e)
}


register_expectation <- function(e) {
  print(e)
  # calls <- e$expectation_calls
  # srcref <- find_first_srcref(calls)
  # 
  # e <- as.expectation(e, srcref = srcref)
  # e$call <- calls
  # e$start_frame <- attr(calls, "start_frame")
  # e$end_frame <- e$start_frame + length(calls) - 1L
  # e$test <- test %||% "(unknown)"
  # ok <<- ok && expectation_ok(e)
  test_expect<-test_expect+1
  # get_reporter()$add_result(context = get_reporter()$.context, test = test, result = e)
}

test_env <- new.env(parent = env)
tryCatch(
  withCallingHandlers(
    {
      eval(code, test_env)
      
      if (!handled && !is.null(test)) {
        skip_empty()
      }
    },
    expectation = handle_expectation,
    skip =        handle_skip,
    warning =     handle_warning,
    message =     handle_message,
    error =       handle_error
  ),
  # some errors may need handling here, e.g., stack overflow
  error = handle_fatal,
  # skip silently terminate code
  skip  = function(e) {}
)
